tcp/udp协议：tcp协议是建立在连接之上的，udp则无连接
		tcp：连接可靠
		udp：速度快

三次握手：客户端向服务端发起连接请求syn包，服务端响应ask，客户端接收后再发送ask确认建立连接
		因为相互之间发送了三包数据，所以称为三次握手

为什么不能是两次握手：不能两次握手的原因是在不可靠的链路上建立起可靠的连接
				在客户端向服务端发送syn包时，数据可能因为某些原因滞后到达，
				在连接之后到达会导致服务端以为又建立起新的连接，导致客户端服务端状态
				不对等

四次挥手：客户端向服务端发送fn包要求断开连接，服务端发送ask响应，此时客户端任然可以接收数据
		服务端任然可以发送未发送完的数据，当服务端发送fn包后，客户端发送ask包后进入定时阶段
		服务端接收到ask后立马断开连接，客户端在等待时间结束后断开连接

为什么客户端要有等待时间：与三次握手相同，在不可靠的链路上实现可靠的链接断开。
				客户端发送的ask可能未到达服务端，这时如果断开连接客户端就一直处于接受
				ask阶段，在等待时间内如果客户端未曾接收到ask就会重发fn包，
				服务端接收后会重新发送ask响应并重置等待时间。

响应式原理：根据obj对象创建一个weakMap数据类型将obj对象存储起来
		const objWeakMap = new weakMap()
		const objMap = new Map()
		objMap.set('name', [fn1, fn2])
		objWeakMap.set(obj, objMap)，键为obj对象，值为一个map数据类型
		当obj中某个属性发生变化时通过proxy或者object.defineProperty()监听到数据变化
		通过objWeakMap.get(obj)取出obj对应的map数据类型
		再根据具体发生变化的值从map数据类型中取出对应需要调用的方法
		objMap.get('name').forEach(item => item())

nextTick： 将包裹的回调函数放在DOM更新之后在执行，在更改了一些数据等待DOM更新之后立即执行
		原理：nextTick的实现和js的事件循环有关，当我们执行一个DOM事件时，这个DOM事件的
			回调函数是一个宏任务，微任务队列默认是没有任务的，此时去执行这个DOM事件的
			回调函数，如果该函数内对某些数据进行了更改，又对这些数据进行了打印读取操作
			如果读取这些数据没有使用nextTcik包裹回调的话，打印的这些数据是DOM更新之前
			的数据，此时还没有进行DOM更新，只有当DOM事件的同步代码全部执行完之后，
			Vue才会将组件更新等操作放进微任务队列中，此时再去执行更新的操作。nextTick
			包裹的回调就是放在这些组件更新的操作后面，所以如果在DOM事件中需要获取数据
			更改之后的值只需要对获取的操作用nextTick进行包裹就可以了，这个回调会在DOM
			发生更新之后在执行。

webpack里loader和plugin的区别：webpack只能打包符合commonJS规范的文件，其它的资源类似图片
					    和css，webpack无法进行打包，只能通过loader进行转化
					    plugin的功能要更为丰富，它除了可以对资源进行加载还可以压缩
					    打包、优化。

重排(回流)和重绘：当dom的几何属性发生了改变会引起页面重排，当dom的非几何属性发生改变就会
		         引起重绘。重排的范围是大于重绘的。重绘不一定引起重排，但重排一定会引起重绘

http1.0/1.1/2/3：http1.0连接方式为短连接，每次请求都要建立一个tcp连接。
		       http1.1解决了1.0出现的问题，连接方式使用长连接，无需多次建立tcp连接，减小了
		       服务器端开销。支持管道网络传输，发出一个请求之后不必等待其回来就可发送请求
		       但是这会导致请求阻塞的问题，一旦有一个请求被阻塞了就导致后面的请求都被阻塞
		       http2.0进行了头部压缩，请求的头部是一样的或者相似的协议就会消除重复部分
		       全面采用二进制格式。支持多路复用，解决了阻塞的问题。可以并发请求。
		       http3.0解决了http2.0出现的多个请求复用同一个tcp连接的问题，这导致有一个请求
		       掉包之后就会导致后续的请求要等到被丢失的这个包重新传回来在执行。http3.0将tcp
		       更换成了udp连接，udp连接不管顺序不管丢包。但是它建立的连接是不安全的，所以
		       要使用基于udp连接的quic协议。

vue优化：v-for增加key值，并且避免v-for和v-if同时使用
	     路由懒加载
	     避免所有的数据都存放在data中，他会增加getter和setter以及对应的watch

前端性能优化：分为两个方面，文件加载变小，文件渲染变少，加载变小：压缩图片，减少http请求：
		   可以使用精灵图等，使用防抖节流等方式减少请求，使用http、本地、vue keep-alive
		   缓存等。
		   渲染变少：直接通过ssr服务端渲染，使用懒加载的方式减少，减少阻塞，css放在头部，
		   js放在body的尾部。

js继承：原型继承：子类的原型prototype通过new Parent()的方式实现继承，缺点：所有子类共享一个
		         父类原型
	  借用构造函数继承：在子类中通过Parent.call()的方式将子类中的this传进父类， 缺点：只继承
				  了父类当中的属性和方法，没有继承到原型
	  组合继承：组合继承是利用原型继承加上构造函数继承实现的，缺点：调用了两次父类，构造出
		        了两个父类实例
	  寄生组合继承：在组合继承的基础上，将子类prototype等于new Parent()换成了一个中间函数
			     这样就不会造成构造出两次父类实例。

v8引擎解析js原理：当浏览器加载js文件时会通过js引擎来解析js文件，以谷歌浏览器为例，v8引擎会通过
		         词法分析和语法分析将js代码生成AST语法树，然后根据v8中的ignition库将AST语法树
		         转化成字节码，然后再转化成汇编指令。转化成字节码而不直接转化成汇编指令是
		         因为字节码具有跨平台的作用。
		         因为不同的环境它的cpu指令不一样，所以不能直接转化成汇编。v8引擎还会通过ignition
		         库对重复执行的某些代码进行标记，将他们标记成热代码，通过turbofan库将这些热代码
		         直接转化成对应的机器码，在执行热代码的时候直接执行机器码输出结果就可以了。
		         这里的热代码会有个问题，例如将两个数字相加的函数转化成对应的机器码之后，如果
		         没有限制类型的话，让两个字符串进行相加，这时他们的机器码是不一样的，不能再
	  	         使用之前转化的机器码了，所以这里会有一步反优化的操作，将机器码再转化成字节码。

vue mixin混入的执行时机：对于生命周期，优先执行mixin中的生命周期，对于相同的方法和变量
				  mixin中的方法和变量会被覆盖

